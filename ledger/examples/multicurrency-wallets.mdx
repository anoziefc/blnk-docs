---
title: Building multi-currency wallets
---

## Overview

A multi-currency wallet system is a system that manages balances and transactions between 2 or more [asset classes](../guide/asset-classes). In this example, you'll learn how to build a simple ledger that manages transaction workflows between multiple currencies.

We'll learn about:

- Defining and creating your ledger structure
- Balance creation
- Moving money into wallets
- Moving money out of wallets
- Moving money between multi-currency wallets
- Managing side effects with Inflight

## 1. Ledger Structure

The entry point of the Blnk ledger system is ledger folders. These folders serve as a way to group and manage assets, accounts, and balances that fit your product or organization's structure.

In this guide, we'll use a simple structure:

- **USD Ledger:** Contains all USD wallets
- **EUR Ledger:** Contains all EUR wallets

<Tip>
    The ledger structure is flexible and can be customized based on your specific needs. For instance, you could group by users instead of currencies, or use a combination of both.
</Tip>

**See also:**
- [Create a ledger](../tutorial/create-a-ledger)
- [Ledger architecture](../guide/ledger-architecture)

<Steps>
    <Step title="Creating a USD Ledger">
        ```javascript NodeJS
            const request = require('request');

            const options = {
            method: 'POST',
            url: 'localhost:5001/ledgers',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': 'YOUR_AUTH_TOKEN_HERE'`
            },
            body: JSON.stringify({
                "name": "Customer USD Ledger",
                "meta_data": {
                "project_name": "SendWorld App"
                }
            })
            };

            request(options, (error, response) => {
            if (error) throw new Error(error);
            console.log(response.body);
            });
        ```

        ```json Response
            {
                "ledger_id": "ldg_5dff0196-11f6-4674-87a2-cf3e39bd20d2",
                "name": "Customer USD Ledger",
                "created_at": "2024-07-05T08:06:26.84333909Z",
                "meta_data": {
                    "project_name": "SendWorld App"
                }
            }
        ```
        <Note>
          Always store the `ledger_id` in your database. You'll need it for future operations related to this ledger.
        </Note>
    </Step>
    <Step title="Creating a EUR Ledger">
        It is the same process as the USD ledger creation. Only change the `name` of the ledger and adjust the `meta_data` as needed.
        ```javascript NodeJS
            const request = require('request');

            const options = {
            method: 'POST',
            url: 'localhost:5001/ledgers',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': 'YOUR_AUTH_TOKEN_HERE'
            },
            body: JSON.stringify({
                "name": "Customer EUR Ledger",
                "meta_data": {
                "project_name": "SendWorld App"
                }
            })
            };

            request(options, (error, response) => {
            if (error) throw new Error(error);
            console.log(response.body);
            });
        ```

        ```json Response
            {
                "ledger_id": "ldg_4b53fb9a-bec7-423b-bfc5-106c6241131f",
                "name": "Customer EUR Ledger",
                "created_at": "2024-07-05T08:09:40.471331305Z",
                "meta_data": {
                    "project_name": "SendWorld App"
                }
            }
        ```
    </Step>
</Steps>

## 2. Balance (Wallet) Creation

Blnk uses the concept of ledger balances to manage accounts/balances in a ledger. In our example, we'll create wallets for a customer named Jerry, who will have both a USD and EUR wallet.

**See also:**
- [Create a balance](../tutorial/create-a-balance)
- [Balance monitoring](../tutorial/balance-monitoring)

<Steps>
    <Step title="Creating a USD Wallet for Customer A">
        ```javascript NodeJS
            const request = require('request');

            const options = {
            method: 'POST',
            url: 'localhost:5001/balances',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                "ledger_id": "ldg_5dff0196-11f6-4674-87a2-cf3e39bd20d2",
                "currency": "USD",
                "meta_data": {
                "customer_name": "Jerry",
                "customer_internal_id": "1234"
                }
            })
            };

            request(options, (error, response) => {
            if (error) throw new Error(error);
            console.log(response.body);
            });
        ```

        ```json Response
            {
                "balance": 0,
                "version": 0,
                "inflight_balance": 0,
                "credit_balance": 0,
                "inflight_credit_balance": 0,
                "debit_balance": 0,
                "inflight_debit_balance": 0,
                "precision": 0,
                "ledger_id": "ldg_5dff0196-11f6-4674-87a2-cf3e39bd20d2",
                "identity_id": "",
                "balance_id": "bln_e39a239a-a6ca-4509-b0d9-29dcc5630f8a",
                "indicator": "",
                "currency": "USD",
                "created_at": "2024-07-05T08:13:18.882616461Z",
                "meta_data": {
                    "customer_internal_id": "1234",
                    "customer_name": "Jerry"
                }
            }
        ```
        <Warning>
            The `balance_id` is important. Always store this in your database and associate it with the customer. You'll use this `id` for all future transactions involving this wallet.
        </Warning>
    </Step>
    <Step title="Creating a EUR Wallet for Customer A">
        It is the same process as the USD wallet creation. Only change the ledger_id to the EUR ledger ID and set the currency to "EUR".

        ```javascript NodeJS
            // ... (similar to USD wallet creation)
            body: JSON.stringify({
            "ledger_id": "ldg_4b53fb9a-bec7-423b-bfc5-106c6241131f",
            "currency": "EUR",
            "meta_data": {
                "customer_name": "Jerry",
                "customer_internal_id": "1234"
            }
            })
            // ...
        ```

        ```json Response
            {
                "balance": 0,
                "version": 0,
                "inflight_balance": 0,
                "credit_balance": 0,
                "inflight_credit_balance": 0,
                "debit_balance": 0,
                "inflight_debit_balance": 0,
                "precision": 0,
                "ledger_id": "ldg_4b53fb9a-bec7-423b-bfc5-106c6241131f",
                "identity_id": "",
                "balance_id": "bln_f945f959-bebf-4764-ab2d-2ae194c1b93e",
                "indicator": "",
                "currency": "EUR",
                "created_at": "2024-07-05T08:13:58.533433549Z",
                "meta_data": {
                    "customer_internal_id": "1234",
                    "customer_name": "Jerry"
                }
            }
        ```
    </Step>
</Steps>

## 3. Moving Money into Wallets

Once ledgers are created and balances/wallets have been set up for your customers, the next step is to start recording transactions.

In this example, we'll cover funding our wallets with actual cash received from the outside world or other apps (banks/wallets etc). This section introduces key concepts in Blnk like:

- [General Ledgers](../tutorial/internal-balances)
- [Overdrafts](../tutorial/overdrafts)
- [`meta_data`](../tutorial/record-a-transaction).

**See also:**
- [Record a transaction](../tutorial/record-a-transaction)
- [Understanding precision](../tutorial/precision)

<Steps>
    <Step title="Funding Customer A's USD Wallet with $200.00">

        ```javascript NodeJS
            const request = require('request');

            const options = {
            method: 'POST',
            url: 'localhost:5001/transactions',
            headers: {
                'X-Blnk-Key': 'blnk-api',
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                "amount": 200,
                "precision": 100,
                "reference": "ref-0-01",
                "description": "payment for service rendered",
                "currency": "USD",
                "source": "@World",
                "destination": "bln_e39a239a-a6ca-4509-b0d9-29dcc5630f8a",
                "allow_overdraft": true,
                "meta_data": {
                "sender_name": "Future Design LLC",
                "sender_internal_id": "123333"
                }
            })
            };

            request(options, (error, response) => {
            if (error) throw new Error(error);
            console.log(response.body);
            });
        ```

        ```json Response
            {
                "precise_amount": 20000,
                "amount": 200,
                "rate": 0,
                "precision": 100,
                "transaction_id": "txn_30b149f0-4d7c-42e0-bf62-24f2cd33812a",
                "parent_transaction": "",
                "source": "@World",
                "destination": "bln_e39a239a-a6ca-4509-b0d9-29dcc5630f8a",
                "reference": "ref-0-01",
                "currency": "USD",
                "description": "payment for service rendered",
                "status": "QUEUED",
                "hash": "21182dc6d5ede048a82afa0883f56dd422a74402acf6b6a3dce16524d6c2af3a",
                "allow_overdraft": true,
                "inflight": false,
                "created_at": "2024-07-05T08:21:04.001458635Z",
                "scheduled_for": "0001-01-01T00:00:00Z",
                "inflight_expiry_date": "0001-01-01T00:00:00Z",
                "meta_data": {
                    "sender_internal_id": "123333",
                    "sender_name": "Future Design LLC"
                }
            }
        ```
        | Field | Description |
        | --- | --- |
        |`amount` | The actual amount received, in this case 200.00 USD. |
        |`precision` | Blnk uses the concept of precision to accurately manage and store float amounts. For accuracy, always pass a precision to convert the original amount to its lowest denominator (without floats). In this case, to convert USD to cents, we use a precision of 100. So, 200.00 USD * 100 = 20000 cents. |
        |`source` | The source is part of Blnk's implementation of the double-entry accounting principle. In this example, the amount was debited from the outside world (sender) and credited to one of our internal wallets. We use the concept of general ledgers to keep a record of all money coming from the outside world into our ledger. To easily do this without having to create a new ledger folder called general ledger (Blnk does this automatically), you can use the @ prefix followed by what you want to name the general ledger balance. In this case, it's `@World`. You can name it anything, for example, `@external-service-partner` if you are receiving the payment from an external partner and want to track how much you've received or sent to the partner. |
        |`destination` | In this example, the destination is Customer A's USD wallet, which we pass using the `balance_id` obtained when the balance was created: `bln_e39a239a-a6ca-4509-b0d9-29dcc5630f8a.` |
        |`allow_overdraft` | Since we're tracking the general ledger balances (in this case, `@World`), we're essentially moving 200.00 USD from the `@World` balance to Customer A's USD balance. But since in our application the `@World` balance is empty initially, we want to force an overdraft so the transaction goes through. If overdraft is not true, the transaction will be rejected with insufficient funds because the `@World` general ledger balance is empty at the beginning. Setting overdraft to true enables us to debit past the balance. |
        |`meta_data` | This field allows you to store additional information about the transaction. It's crucial for reconciliation and auditing purposes. |
        <Tips>
            Always use the precision field to avoid floating-point arithmetic issues. For USD and EUR, a precision of 100 (representing cents) is typically used.
        </Tips>
    </Step>
    <Step title="Funding Customer A's EUR Wallet with 3500.50 EUR">
        The process is similar to funding the USD wallet. Here's the key part of the request body.

        ```javascript NodeJS
            body: JSON.stringify({
                "amount": 3500.5,
                "precision": 100,
                "reference": "ref-0-02",
                "description": "invoice A fulfilled",
                "currency": "EUR",
                "source": "@World",
                "destination": "bln_f945f959-bebf-4764-ab2d-2ae194c1b93e",
                "allow_overdraft": true,
                "meta_data": {
                    "sender_name": "Nlnk Bank",
                    "sender_internal_id": "563825"
                }
            })
        ```
        <Note>
            The principles explained for the USD transaction apply here as well. Always ensure you're using the correct precision and currency for each transaction.
        </Note>
    </Step>
</Steps>

## 4. Moving Money out of Wallets

Once the ledgers are created and balances/wallets have been set up for your customers, and the wallets have been funded, you can record transactions that move money out of the wallets.

**See also:**
- [Multiple sources](../tutorial/multiple-sources)
- [Multiple destinations](../tutorial/multiple-destinations)

<Steps>
    <Step title="Transferring $70.32 from Customer A's USD Wallet">

        ```javascript NodeJS
            const request = require('request');

            const options = {
            method: 'POST',
            url: 'localhost:5001/transactions',
            headers: {
                'X-Blnk-Key': 'blnk-api',
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                "amount": 70.32,
                "precision": 100,
                "reference": "ref-0-03",
                "description": "payment for blnk subscription",
                "currency": "USD",
                "source": "bln_e39a239a-a6ca-4509-b0d9-29dcc5630f8a",
                "destination": "@World"
            })
            };

            request(options, (error, response) => {
            if (error) throw new Error(error);
            console.log(response.body);
            });
        ```

        ```json Response
            {
                "precise_amount": 7032,
                "amount": 70.32,
                "rate": 0,
                "precision": 100,
                "transaction_id": "txn_821376a4-7aae-40dd-b390-1e802c450cf5",
                "parent_transaction": "",
                "source": "bln_e39a239a-a6ca-4509-b0d9-29dcc5630f8a",
                "destination": "@World",
                "reference": "ref-0-03",
                "currency": "USD",
                "description": "payment for blnk subscription",
                "status": "QUEUED",
                "hash": "18f45e1166a0def50fd97d85e4ce146d820cbe376f1df7654e99184ae5504104",
                "allow_overdraft": false,
                "inflight": false,
                "created_at": "2024-07-05T08:43:19.427753627Z",
                "scheduled_for": "0001-01-01T00:00:00Z",
                "inflight_expiry_date": "0001-01-01T00:00:00Z"
            }
        ```
        | Field | Description |
        | --- | --- |
        |`amount` | The amount to be transferred, in this case 70.32 USD. |
        |`precision` | As before, we use 100 to represent cents. |
        |`source` | This time, we're transferring from the customer's wallet, so we use the `balance_id` of their USD wallet. |
        |`destination` | We're transferring to the outside world, so we use "@World". |
        |`allow_overdraft` | This is set to false because we don't want to allow the customer's balance to go negative. |
        <Warning>
            Always check the balance after a transaction to ensure it's updated correctly. Here's how you might do that.
        </Warning>

        ```javascript NodeJS
            const checkBalance = (balanceId) => {
            const options = {
                method: 'GET',
                url: `localhost:5001/balances/${balanceId}`,
                headers: {
                'X-Blnk-Key': 'blnk-api',
                'Content-Type': 'application/json'
                }
            };

            request(options, (error, response) => {
                if (error) throw new Error(error);
                console.log('Updated balance:', JSON.parse(response.body).balance);
            });
            };

            // Use it after a transaction
            checkBalance('bln_e39a239a-a6ca-4509-b0d9-29dcc5630f8a');
        ```

        **Balance after the transaction:**
        ```json Response
            {
                "balance": 12969,
                "version": 3,
                "inflight_balance": 0,
                "credit_balance": 20000,
                "inflight_credit_balance": 0,
                "debit_balance": 7031,
                "inflight_debit_balance": 0,
                "precision": 0,
                "ledger_id": "ldg_5dff0196-11f6-4674-87a2-cf3e39bd20d2",
                "identity_id": "",
                "balance_id": "bln_e39a239a-a6ca-4509-b0d9-29dcc5630f8a",
                "indicator": "",
                "currency": "USD",
                "created_at": "2024-07-05T08:13:18.882616Z",
                "inflight_expires_at": "0001-01-01T00:00:00Z",
                "meta_data": null
            }
        ```
        <Note>
            Note that the balance has decreased by 7031 cents (70.31 USD), which matches our transaction amount.
        </Note>
    </Step>
    <Step title="Transferring 1470.49 EUR from Customer A's EUR Wallet">
        The process is similar to the USD transfer. Here's the key part of the request body:

        ```javascript NodeJS
            body: JSON.stringify({
            "amount": 1470.49,
            "precision": 100,
            "reference": "ref-0-05",
            "description": "payment for new iphone",
            "currency": "EUR",
            "source": "bln_f945f959-bebf-4764-ab2d-2ae194c1b93e",
            "destination": "@world"
            })
        ```
        <Warning>
            Always ensure you're using the correct `balance_id` for the source wallet and the correct currency for each transaction.
        </Warning>
    </Step>
</Steps>

## 5. Moving Money Between Multi-Currency Wallets

Blnk supports moving money between balances of different currencies. This feature is crucial for applications dealing with multiple currencies.

**See also:**
- [Applying rates](../tutorial/applying-rates)

### Converting $100 USD to EUR (at a rate of 1 USD = 0.92 EUR)

        ```javascript NodeJS
            const request = require('request');

            const options = {
            method: 'POST',
            url: 'localhost:5001/transactions',
            headers: {
                'X-Blnk-Key': 'blnk-api',
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                "amount": 100,
                "precision": 100,
                "reference": "ref-0-06",
                "description": "convert to EURO",
                "currency": "USD",
                "source": "bln_e39a239a-a6ca-4509-b0d9-29dcc5630f8a",
                "destination": "bln_f945f959-bebf-4764-ab2d-2ae194c1b93e",
                "rate": 0.92,
                "meta_data": {
                "rate_timestamp": "1720169821",
                "rate_source": "Google Rates"
                }
            })
            };

            request(options, (error, response) => {
            if (error) throw new Error(error);
            console.log(response.body);
            });
        ```

        ```json Response
            {
                "precise_amount": 10000,
                "amount": 100,
                "rate": 0.92,
                "precision": 100,
                "transaction_id": "txn_df9355d3-cac9-483d-90f3-58ed5d4c767f",
                "parent_transaction": "",
                "source": "bln_e39a239a-a6ca-4509-b0d9-29dcc5630f8a",
                "destination": "bln_f945f959-bebf-4764-ab2d-2ae194c1b93e",
                "reference": "ref-0-06",
                "currency": "USD",
                "description": "convert to EURO",
                "status": "QUEUED",
                "hash": "27a8389243f90f949c3552eb638ce0a86896bca763643d90c182ffd3e2538a33",
                "allow_overdraft": false,
                "inflight": false,
                "created_at": "2024-07-05T08:58:01.82018405Z",
                "scheduled_for": "0001-01-01T00:00:00Z",
                "inflight_expiry_date": "0001-01-01T00:00:00Z",
                "meta_data": {
                    "rate_source": "Google Rates",
                    "rate_timestamp": "1720169821"
                }
            }
        ```
        | Field | Description |
        | --- | --- |
        |`amount` | The amount to be converted, in this case 100 USD. |
        |`precision` | As before, we use 100 to represent cents. |
        |`source` | The `balance_id` of the USD wallet. |
        |`destination` | The `balance_id` of the EUR wallet. |
        | `rate` | The conversion rate from USD to EUR. In this case, 1 USD = 0.92 EUR. |
        |`meta_data` | It's crucial to store information about the rate used and its source for auditing purposes. |
        <Warning>
            Always store the conversion rate and its source in the meta_data. This is crucial for auditing and reconciliation.
        </Warning>
        After this transaction, you should check both the USD and EUR balances

        **USD Balance after the transaction:**
        ```json Response
            {
                "balance": 2969,
                "version": 4,
                "inflight_balance": 0,
                "credit_balance": 20000,
                "inflight_credit_balance": 0,
                "debit_balance": 17031,
                "inflight_debit_balance": 0,
                "precision": 0,
                "ledger_id": "ldg_5dff0196-11f6-4674-87a2-cf3e39bd20d2",
                "identity_id": "",
                "balance_id": "bln_e39a239a-a6ca-4509-b0d9-29dcc5630f8a",
                "indicator": "",
                "currency": "USD",
                "created_at": "2024-07-05T08:13:18.882616Z",
                "inflight_expires_at": "0001-01-01T00:00:00Z",
                "meta_data": null
            }
        ```
        **EUR Balance after the transaction:**
        ```json Response
            {
                "balance": 212201,
                "version": 4,
                "inflight_balance": 0,
                "credit_balance": 359250,
                "inflight_credit_balance": 0,
                "debit_balance": 147049,
                "inflight_debit_balance": 0,
                "precision": 0,
                "ledger_id": "ldg_4b53fb9a-bec7-423b-bfc5-106c6241131f",
                "identity_id": "",
                "balance_id": "bln_f945f959-bebf-4764-ab2d-2ae194c1b93e",
                "indicator": "",
                "currency": "EUR",
                "created_at": "2024-07-05T08:13:58.533434Z",
                "inflight_expires_at": "0001-01-01T00:00:00Z",
                "meta_data": null
            }
        ```
        <Note>
            Note that the USD balance has decreased by 10000 cents (100 USD), and the EUR balance has increased by 9200 cents (92 EUR), which matches our conversion rate.
        </Note>

## Best Practices

1. **Immediate Action**: [Process refunds](../tutorial/refund-transactions) as soon as you receive notification of a failed verification to ensure good customer experience.
2. **Detailed Logging**: Always include detailed information in the `meta_data` field. This aids in troubleshooting and auditing.
3. **Balance Verification**: Always verify the balance after processing a refund to ensure the transaction was successful.
4. **Error Handling**: Implement robust error handling in your refund process. If a refund fails, you may need to retry or escalate to manual intervention.
5. **Customer Communication**: Implement a system to notify customers about the failed transaction and subsequent refund.
6. **Reconciliation**: Regularly reconcile your internal records with Blnk's transaction and refund logs to ensure accuracy.
7. **Verify Webhook Authenticity**: In a production environment, implement a mechanism to verify that the webhook is genuinely from your payment provider. This often involves checking a signature or secret key.
8. **Idempotency**: Ensure your webhook handler is idempotent. Providers may send the same webhook multiple times, so your system should handle duplicate notifications gracefully.
9. **Asynchronous Processing**: For high-volume systems, consider processing webhooks asynchronously. You can acknowledge receipt immediately and process the webhook contents in a background job.
10. **Monitoring**: Set up monitoring and alerting for your webhook endpoint. This can help you quickly identify and respond to any issues in the payment verification and refund process.

## Managing Side Effects with Inflight

When dealing with financial transactions, it's crucial to handle scenarios where additional verification or processing time is needed. 

Blnk's Inflight feature provides a powerful tool for managing transactions that require additional steps or approvals before being finalized. This feature allows you to hold funds without applying the transaction until certain conditions are met.

### Overview of Blnk Inflight

Inflight is a transaction parameter that instructs Blnk to hold on applying a transaction until a specified condition has been met. This condition could be confirming that it has been processed by your payment partners or custom conditions set by your application.

Key benefits of using Inflight:

- Manages transactions that may take time to complete.
- Ensures funds are not available for spending until the transaction is finalized.
- Eliminates the need for refunds when partners return a failed response.

### Example: Using Inflight for a payment requiring additional information

Let's consider a scenario where we need to transfer $750.00 from Customer A's USD wallet to an external payment provider, but the payment requires additional verification before being finalized. We'll use the Inflight feature to manage this process.

First, let's initiate the transaction with the Inflight flag:

```javascript NodeJS
const axios = require('axios');

async function createInflightTransaction() {
  try {
    const response = await axios.post('localhost:5001/transactions', {
      amount: 750.00,
      precision: 100,
      reference: "ref_001adcfgf",
      description: "Payment to ExternalProvider (Pending Verification)",
      currency: "USD",
      source: "bln_28edb3e5-c168-4127-a1c4-16274e7a28d3",
      destination: "bln_ebcd230f-6265-4d4a-a4ca-45974c47f746",
      inflight: true,
      inflight_expiry_date: "2024-02-03T12:38:19Z",
      meta_data: {
        provider_reference: "ext-pay-123456",
        customer_id: "1234",
        verification_status: "PENDING"
      }
    }, {
      headers: {
        'X-Blnk-Key': 'your-blnk-api-key-here',
        'Content-Type': 'application/json'
      }
    });

    console.log('Inflight transaction created:', response.data);
    return response.data;
  } catch (error) {
    console.error('Error creating inflight transaction:', error.response.data);
    throw error;
  }
}

createInflightTransaction();
```
```json Expected response
{
    "transaction_id": "txn_6164573b-6cc8-45a4-ad2e-7b4ba6a60f7d",
    "source": "bln_28edb3e5-c168-4127-a1c4-16274e7a28d3",
    "destination": "bln_ebcd230f-6265-4d4a-a4ca-45974c47f746",
    "reference": "ref_001adcfgf",
    "parent_transaction": "",
    "amount": 750.00,
    "precise_amount": 75000,
    "rate": 0,
    "precision": 100,
    "currency": "USD",
    "description": "Payment to ExternalProvider (Pending Verification)",
    "status": "INFLIGHT",
    "hash": "032af5e26c8a2c2690f1bb70bdd7c044bbdf9c7f5576fc0f693200baf65a9ee3",
    "allow_overdraft": false,
    "inflight": true,
    "created_at": "2024-02-20T05:28:03Z",
    "scheduled_for": "0001-01-01T00:00:00Z",
    "inflight_expiry_date": "2024-02-03T12:38:19Z",
    "meta_data": {
        "provider_reference": "ext-pay-123456",
        "customer_id": "1234",
        "verification_status": "PENDING"
    }
}
```

### How Inflight works

When you enable `inflight` on a transaction:

1. The transaction is added to the queue with status QUEUED.
2. Once ready for processing, the status changes to INFLIGHT.
3. The inflight balances of the participating ledger balances (`source` and `destination`) are updated:
    - inflight_credit_balance: Total amount waiting to be credited.
    - inflight_debit_balance: Total amount waiting to be debited.
4. The amount is debited from the source's `inflight_debit_balance` and credited to the destination's `inflight_credit_balance`.
5. The main balances of the source and destination remain untouched until the transaction is finalized.

### Handling webhooks and automating inflight transaction resolution

Let's set up a simple Express.js server to handle webhooks and automate the Inflight transaction resolution process:

```javascript NodeJS
const express = require('express');
const bodyParser = require('body-parser');
const axios = require('axios');

const app = express();
app.use(bodyParser.json());

// Webhook endpoint
app.post('/payment-webhook', async (req, res) => {
  const { status, providerReference, amount, currency } = req.body;

  console.log(`Received webhook: Status ${status} for payment ${providerReference}`);

  try {
    if (status === 'VERIFIED') {
      console.log(`Payment ${providerReference} verified. Committing transaction.`);
      await commitInflightTransaction(providerReference);
    } else if (status === 'REJECTED') {
      console.log(`Payment ${providerReference} rejected. Voiding inflight transaction.`);
      await voidInflightTransaction(providerReference);
    }
    res.sendStatus(200);
  } catch (error) {
    console.error('Error processing webhook:', error);
    res.status(500).send('Error processing webhook');
  }
});

async function findTransactionId(providerReference) {
  // In a real-world scenario, you would query your database here
  // This is a placeholder implementation
  return "txn_6164573b-6cc8-45a4-ad2e-7b4ba6a60f7d";
}

async function commitInflightTransaction(providerReference) {
  const transactionId = await findTransactionId(providerReference);

  try {
    const response = await axios.post(`http://localhost:5001/transactions/${transactionId}/inflight`, {
      status: "commit",
      meta_data: {
        verification_status: "VERIFIED",
        provider_reference: providerReference
      }
    }, {
      headers: {
        'X-Blnk-Key': 'your-blnk-api-key-here',
        'Content-Type': 'application/json'
      }
    });

    console.log('Transaction committed successfully:', response.data);
    // Here you might want to update your internal database, notify the customer, etc.
  } catch (error) {
    console.error('Error committing transaction:', error.response.data);
    throw error;
  }
}

async function voidInflightTransaction(providerReference) {
  const transactionId = await findTransactionId(providerReference);

  try {
    const response = await axios.post(`http://localhost:5001/transactions/${transactionId}/inflight`, {
      status: "void",
      meta_data: {
        verification_status: "REJECTED",
        provider_reference: providerReference
      }
    }, {
      headers: {
        'X-Blnk-Key': 'your-blnk-api-key-here',
        'Content-Type': 'application/json'
      }
    });

    console.log('Transaction voided successfully:', response.data);
    // Here you might want to update your internal database, notify the customer, etc.
  } catch (error) {
    console.error('Error voiding transaction:', error.response.data);
    throw error;
  }
}

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => console.log(`Server running on port ${PORT}`));
```

This example demonstrates:

1. Setting up a webhook endpoint to receive notifications from your payment provider.
2. Processing the webhook based on the payment status (VERIFIED or REJECTED).
3. Committing or voiding the Inflight transaction accordingly.
4. Error handling and logging.

### Using expiry dates with inflight transactions

Expiration dates are crucial for managing Inflight transactions effectively. They ensure that transactions don't remain in a pending state indefinitely, which could potentially lock funds unnecessarily.

### Example: Setting and handling expiration

```javascript NodeJS
const axios = require('axios');

async function createInflightTransactionWithExpiry() {
  const expiryDate = new Date();
  expiryDate.setHours(expiryDate.getHours() + 24); // Set expiry to 24 hours from now

  try {
    const response = await axios.post('localhost:5001/transactions', {
      amount: 750.00,
      precision: 100,
      reference: "ref_001adcfgf",
      description: "Payment to ExternalProvider (Pending Verification)",
      currency: "USD",
      source: "bln_28edb3e5-c168-4127-a1c4-16274e7a28d3",
      destination: "bln_ebcd230f-6265-4d4a-a4ca-45974c47f746",
      inflight: true,
      inflight_expiry_date: expiryDate.toISOString(),
      meta_data: {
        provider_reference: "ext-pay-123456",
        customer_id: "1234",
        verification_status: "PENDING"
      }
    }, {
      headers: {
        'X-Blnk-Key': 'your-blnk-api-key-here',
        'Content-Type': 'application/json'
      }
    });

    console.log('Inflight transaction created with expiry:', response.data);
    return response.data;
  } catch (error) {
    console.error('Error creating inflight transaction:', error.response.data);
    throw error;
  }
}

createInflightTransactionWithExpiry();
```

<Note>
    Blnk automatically voids the transaction once the expiration date is met and the transaction has not been committed fully.
</Note>

### Implementing partial commits for inflight transactions

Partial commits allow you to finalize a portion of an Inflight transaction while keeping the remainder in the Inflight state. This is particularly useful for scenarios where a transaction may be processed in parts.

### Example: Partial commit of an inflight transaction

```javascript NodeJS
async function partialCommitInflightTransaction(transactionId, amountToCommit) {
  try {
    const response = await axios.post(`http://localhost:5001/transactions/${transactionId}/inflight`, {
      status: "commit",
      amount: amountToCommit
    }, {
      headers: {
        'X-Blnk-Key': 'your-blnk-api-key-here',
        'Content-Type': 'application/json'
      }
    });

    console.log('Partial commit successful:', response.data);
    return response.data;
  } catch (error) {
    console.error('Error in partial commit:', error.response.data);
    throw error;
  }
}

// Usage example
async function handlePartialPaymentVerification(transactionId, verifiedAmount) {
  try {
    await partialCommitInflightTransaction(transactionId, verifiedAmount);
    console.log(`Partially committed ${verifiedAmount} for transaction ${transactionId}`);

    // You might want to update your internal records here
    await updateInternalRecords(transactionId, verifiedAmount);

    // Check if there's any remaining amount to be verified
    const remainingAmount = await checkRemainingInflightAmount(transactionId);
    if (remainingAmount > 0) {
      console.log(`Remaining inflight amount for ${transactionId}: ${remainingAmount}`);
    } else {
      console.log(`Transaction ${transactionId} fully committed`);
    }
  } catch (error) {
    console.error('Error handling partial payment verification:', error);
  }
}

async function updateInternalRecords(transactionId, committedAmount) {
  // Implement your logic to update internal records
  console.log(`Updating internal records for ${transactionId} with committed amount ${committedAmount}`);
}

async function checkRemainingInflightAmount(transactionId) {
  // This would typically involve querying Blnk's API or your database
  // For demonstration, we'll return a mock value
  return 250.00; // Assuming 500 out of 750 was committed
}

// Example usage
handlePartialPaymentVerification('txn_6164573b-6cc8-45a4-ad2e-7b4ba6a60f7d', 500.00);
```

In this example:

1. We defined a `partialCommitInflightTransaction` function that commits only a portion of the Inflight transaction.
2. The `handlePartialPaymentVerification` function demonstrates how you might use partial commits in your payment flow:
    - It commits the verified amount.
    - Updates internal records.
    - Checks if there's any remaining amount still in the Inflight state.
3. The `checkRemainingInflightAmount` function (which you would implement to query Blnk's API or your database) helps track the progress of partial commits.

By using partial commits, you can handle complex scenarios where funds are released incrementally, such as:

- Multi-stage payment processes.
- Partial fulfillment of orders.
- Gradual release of funds based on milestone completions in a project.

### Best practices for managing side effects with Inflight

1. **Balance Checks**: Ensure the source balance has enough funds to complete the transaction. Prevent the source balance from having a balance lower than the amount in its inflight_debit_balance.
2. **Available Balance Calculation**: This prevents users from accessing funds that are held in Inflight transactions. In your application, calculate the available balance as:
    
    ```jsx
    const availableBalance = balance - inflight_debit_balance;
    ```
    
    
3. **Error Handling**: Implement robust error handling in your Inflight process. If a commit or void operation fails, you may need to retry or escalate to manual intervention.
4. **Customer Communication**: Implement a system to notify customers about the status of their transactions, especially when they're held in Inflight.
5. **Reconciliation**: Regularly reconcile your internal records with Blnk's transaction logs to ensure accuracy, paying special attention to Inflight transactions.(Blnk v1 will support reconcillation features built into the ledger).
6. **Webhook Authentication**: In a production environment, implement a mechanism to verify that the webhook is genuinely from your payment provider.
7. **Idempotency**: Ensure your webhook handler is idempotent. Providers may send the same webhook multiple times, so your system should handle duplicate notifications gracefully.
8. **Monitoring**: Set up monitoring and alerting for your webhook endpoint and Inflight transactions. This can help you quickly identify and respond to any issues in the payment verification process.

## Need help?

Are you stuck? Do you have a question that isn't answered in this doc? Have you run into a problem you can't solve? Want to file a bug report?

[Join our Discord server](https://discord.gg/7WNv94zPpx) and share your questions/thoughts with other developers building financial applications like you.